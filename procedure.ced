% Procedures
signature(cpi:procedureCommand(Proc, Command) :: proc, [Proc::procedure, Command::command]).

signature(procedure(Proc, Command)::statement, [Proc::procedure, Command::command]).
procedure(Proc, Command) ~> cpi:procedureCommand(Proc, Command) :- builtin:true.

signature(function(Expr, T, Result, Command) :: statement, [Expr::expr(T), T::type, Result::ref(T), Command::command]).
signature(cpi:func(Proc, Result, T) :: procedure, [Proc::procedure, Result::ref(T), T::type]).
function(Expr, T, Result, Command) ~> procedure(cpi:func(Expr, Result, T), Command).

signature(cpi:termClass(TTerm, ClassName)::pred, [TTerm::typedTerm, ClassName::string]).
signature(class(TTerm, ClassName)::statement, [TTerm::typedTerm, ClassName::string]).
commandClass(Cmd, ClassName) ~> cpi:termClass(Cmd::command, ClassName) :- builtin:true.


signature(doAll(List)::command, [List::list(command)]).
commandClass(doAll(_), !('net.nansore.cedalion.cmd.DoAll')).

signature(assign(Ref, Expr, Type)::command, [Ref::ref(Type), Expr::expr(Type), Type::type]).
commandClass(assign(_, _, _), !('net.nansore.cedalion.cmd.Assign')).

signature(doProc(Proc)::command, [Proc::procedure]).
commandClass(doProc(_), !('net.nansore.cedalion.cmd.DoProc')).

signature(readFile(FileName, Namespace, FileContent)::command, [FileName::string, Namespace::string, FileContent::fileContent]).
commandClass(readFile(FileName, Namespace, FileContent), !('net.nansore.cedalion.cmd.ReadFile')).

signature(writeFile(FileName, FileContent)::command, [FileName::string, FileContent::fileContent]).
commandClass(writeFile(FileName, FileContent), !('net.nansore.cedalion.cmd.WriteFile')).

signature(assignFinal(Var, Expr, T)::command, [Var::T, Expr::expr(T), T::type]).
commandClass(assignFinal(Var, Expr, T), !('net.nansore.cedalion.cmd.AssignFinal')).

signature(dbInsert(Statement)::command, [Statement::statement]).
commandClass(dbInsert(Statement), !('net.nansore.cedalion.cmd.DBInsert')).

signature(dbRemove(Statement)::command, [Statement::statement]).
commandClass(dbRemove(Statement), !('net.nansore.cedalion.cmd.DBRemove')).

signature(termToString(TTerm, VarNames, Depth, NsList, Str)::command, [TTerm::typedTerm, VarNames::list(varName), Depth::number, NsList::list(namespacePair), Str::ref(string)]).
commandClass(termToString(TTerm, VarNames, Depth, NsList, Str), !('net.nansore.cedalion.cmd.TermToString')).

signature(stringToTerm(StringRef, NsList, TTerm, VarNames)::command, [StringRef::ref(string), NsList::list(namespacePair), TTerm::typedTerm, VarNames::list(varName)]).
commandClass(stringToTerm(StringRef, NsList, TTerm, VarNames), !('net.nansore.cedalion.cmd.StringToTerm')).

signature(notify(TTerm)::command, [TTerm::typedTerm]).
commandClass(notify(TTerm), !'net.nansore.cedalion.cmd.Notify').

% Open a file
procedure(cpi:openFile(FileName, ResourceName, Namespace), 
	doAll([
		readFile(FileName, Namespace, FileContent),
		assignFinal(Model, fileToModel(FileContent), model),
		dbInsert(loadedFile(ResourceName, FileName, Model)),
		dbInsert(editState(ResourceName, [], [], 0))
	])).

procedure(cpi:closeFile(ResourceName), 
	doAll([
		dbRemove(loadedFile(ResourceName, _, _)),
		dbRemove(editState(ResourceName, _, _, _))
	])).

loadedFile(ResourceName, FileName, Model) ~> fileIsLoaded(ResourceName, FileName, Model) :- builtin:true.
editState(ResourceName, UndoStack, RedoStack, ModifiedCounter) ~> editStateIs(ResourceName, UndoStack, RedoStack, ModifiedCounter) :- builtin:true.

cpi:procedureCommand(cpi:func(fileToModel(builtin:fileContent(Terms, NsList)), ModelRef, model), assign(ModelRef, cpi:constExpr(model(Statements, VarNames, NsList)), model)) :-
	fileModel(Terms, Statements, VarNames).

signature(fileModel(Terms, Statements, VarNames)::pred, [Terms::list(annotatedTerm), Statements::list(statement), VarNames::list(varName)]).
fileModel([], [], []) :- builtin:true.
fileModel([builtin:statement(S, VN1) | Terms], [S | Statements], VarNames) :-
	fileModel(Terms, Statements, VN2),
	mergeVarNames(VN1, VN2, VarNames).


mergeVarNames([], VarNames, VarNames) :- builtin:true.
mergeVarNames([builtin:varName(Var::T, Name) | VN1], VN2, VarNames) :-
	builtin:if(varInVarNames(Var::T, VN2),
		mergeVarNames(VN1, VN2, VarNames),
		%else
		mergeVarNames(VN1, [builtin:varName(Var::T, Name) | VN2], VarNames)).

varInVarNames(Var::T, [builtin:varName(Var1::T, _) | _]) :-
	builtin:equals(Var1::T, Var::T).
varInVarNames(Var::T, [_ | VN]) :-
	varInVarNames(Var::T, VN).


% Save a file
cpi:procedureCommand(cpi:saveFile(ResourceName, FileName), doAll([
		writeFile(FileName, Content),
		dbRemove(editState(ResourceName, _, _, _)),
		dbInsert(editState(ResourceName, UndoStack, RedoStack, 0))	
	])) :-
	fileIsLoaded(ResourceName, _, Model),
	modelToContent(Model, Content),
	editStateIs(ResourceName, UndoStack, RedoStack, _).

modelToContent(model(Statements, VarNames, NsList), builtin:fileContent(AnnoStatements, NsList)) :-
	annotateStatements(Statements, VarNames, AnnoStatements).


annotateStatements([], _, []) :- builtin:true.
annotateStatements([Statement | Statements], VarNames, [builtin:statement(Statement, VN1) | AnnoStatements]) :-
	selectVarNamesFor(Statement::statement, VarNames, VN1),
	annotateStatements(Statements, VarNames, AnnoStatements).

selectVarNamesFor(_, [], []) :- builtin:true.
selectVarNamesFor(TTerm, [builtin:varName(Var::T, Name) | VarNames], VN) :-
	selectVarNamesFor(TTerm, VarNames, VN1),
	builtin:if(varIn(Var::T, TTerm),
		VN = [builtin:varName(Var::T, Name) | VN1],
		% else
		VN = VN1).

varIn(Var::VarType, Term::TermType) :-
	builtin:if(builtin:var(Term::TermType),
		builtin:equals(Var::VarType, Term::TermType),
		(% else
			builtin:compound(Term::TermType),
			builtin:parseTerm(Term::TermType, _, Args),
			varInList(Var::VarType, Args)
		)).

varInList(Var::VarType, [First::FirstType | _]) :-
	varIn(Var::VarType, First::FirstType).

varInList(Var::VarType, [_ | Tail]) :-
	varInList(Var::VarType, Tail).

% Retrieve a term at a given path
cpi:termAtPath(cpi:path(ResourceName, Path), TTerm, VarNames) :-
	fileIsLoaded(ResourceName, _, model(Statements, AllVarNames, _)),
	subTerm(Statements::list(statement), Path, TTerm),
	selectVarNamesFor(TTerm, AllVarNames, VarNames).

subTerm(TTerm, [], TTerm) :- builtin:true.
subTerm(TTerm, [First | Path], TSubTerm) :-
	builtin:parseTerm(TTerm, _, TArgs),
	element(TSubTerm1, First, TArgs, typedTerm),
	subTerm(TSubTerm1, Path, TSubTerm).

% The n'th element of a list (1-based)
signature(element(Elem, Index, List, Type)::pred, [Elem::Type, Index::number, List::list(Type), Type::type]).
element(First, 1, [First | _], _) :- builtin:true.
element(Elem, Index, [_ | Rest], Type) :-
	builtin:succ(IndexMinusOne, Index),
	element(Elem, IndexMinusOne, Rest, Type).

% Modify the n'th element of a list (1-based) to produce a new list
signature(setElement(Index, List, Elem, NewList, Type)::pred, [Index::number, List::list(Type), Elem::Type, NewList::Type, Type::type]).
setElement(1, [_ | Rest], Elem, [Elem | Rest], _) :- builtin:true.
setElement(Index, [First | Rest], Elem, [First | ModRest], Type) :-
	builtin:succ(IndexMinusOne, Index),
	setElement(IndexMinusOne, Rest, Elem, ModRest, Type).

% Modify a term at a given path
cpi:procedureCommand(cpi:setAtPath(cpi:path(ResourceName, Path), TTerm, VarNames2), doAll([
		dbRemove(loadedFile(ResourceName, _, _)),
		dbInsert(loadedFile(ResourceName, FileName, model(Statements, VarNames, NsList)))])) :-
	fileIsLoaded(ResourceName, FileName, model(OldStatements, VarNames1, NsList)),
	replaceSubterm(OldStatements::list(statement), Path, TTerm, Statements::list(statement)),
	mergeVarNames(VarNames1, VarNames2, VarNames).

replaceSubterm(_, [], TTerm, TTerm) :- builtin:true.
replaceSubterm(OldTTerm, [First | Path], RepTTerm, TTerm) :-
	builtin:parseTerm(OldTTerm, Func, OldTArgs),
	replaceNthSubterm(OldTArgs, First, Path, RepTTerm, NewTArgs),
	builtin:parseTerm(TTerm, Func, NewTArgs).

replaceNthSubterm([OldTTerm | TArgs], 1, Path, RepTTerm, [TTerm | TArgs]) :-
	replaceSubterm(OldTTerm, Path, RepTTerm, TTerm).
replaceNthSubterm([First | TArgs], N, Path, RepTTerm, [First | TNewArgs]) :-
	N > 1,
	builtin:succ(NMinus1, N),
	replaceNthSubterm(TArgs, NMinus1, Path, RepTTerm, TNewArgs).

% Edit operation: Modify and update the undo stack
cpi:procedureCommand(cpi:edit(cpi:path(ResourceName, Path), TTerm, VarNames), doAll([
		doProc(cpi:setAtPath(cpi:path(ResourceName, Path), TTerm, VarNames)),
		dbRemove(editState(ResourceName, _, _, _)),
		dbInsert(editState(ResourceName, [editOp(cpi:path(ResourceName, Path), OldTypedContent, OldVarNames) | UndoStack], [], NewModifiedCounter)),
		notify(cpi:path(ResourceName, Path)::cpi:path)
	])) :-
	editStateIs(ResourceName, UndoStack, _, OldModifiedCounter),
	cpi:termAtPath(cpi:path(ResourceName, Path), OldTypedContent, OldVarNames),
	builtin:if(OldModifiedCounter < 0,
		NewModifiedCounter::number = 99999::number,
		%else
		builtin:succ(OldModifiedCounter, NewModifiedCounter)).

% Undo editing
cpi:procedureCommand(cpi:undo(ResourceName), doAll([
		doProc(cpi:setAtPath(cpi:path(ResourceName, Path), TypedContent, VarNames)),
		assignFinal(NewModifiedCounter, cpi:constExpr(OldModifiedCounter) - cpi:constExpr(1), number),
		dbRemove(editState(ResourceName, _, _, _)),
		dbInsert(editState(ResourceName, UndoStack, [editOp(cpi:path(ResourceName, Path), OldTypedContent, OldVarNames) | RedoStack], NewModifiedCounter)),
		notify(cpi:path(ResourceName, Path)::cpi:path)
	])) :-
	editStateIs(ResourceName, [editOp(cpi:path(ResourceName, Path), TypedContent, VarNames) | UndoStack], RedoStack, OldModifiedCounter),
	cpi:termAtPath(cpi:path(ResourceName, Path), OldTypedContent, OldVarNames).

% Redo editing
cpi:procedureCommand(cpi:redo(ResourceName), doAll([
		doProc(cpi:setAtPath(cpi:path(ResourceName, Path), TypedContent, VarNames)),
		assignFinal(NewModifiedCounter, cpi:constExpr(OldModifiedCounter) - cpi:constExpr(1), number),
		dbRemove(editState(ResourceName, _, _, _)),
		dbInsert(editState(ResourceName, [editOp(cpi:path(ResourceName, Path), OldTypedContent, OldVarNames) | UndoStack], RedoStack, NewModifiedCounter)),
		notify(cpi:path(ResourceName, Path)::cpi:path)
	])) :-
	editStateIs(ResourceName, UndoStack, [editOp(cpi:path(ResourceName, Path), TypedContent, VarNames) | RedoStack], OldModifiedCounter),
	cpi:termAtPath(cpi:path(ResourceName, Path), OldTypedContent, OldVarNames).

% Is a resource modified?
cpi:isModified(ResourceName) :-
	editStateIs(ResourceName, _, _, ModifiedCounter),
	\+ModifiedCounter::number == 0::number.

% Arithmetic functions
signature((X+Y)::number, [X::number, Y::number]).
function(X+Y, number, Z, plus(X, Y, Z)).
commandClass(plus(X, Y, Z), !('net.nansore.cedalion.cmd.Plus')).

signature((X-Y)::number, [X::number, Y::number]).
function(X-Y, number, Z, minus(X, Y, Z)).
commandClass(minus(X, Y, Z), !('net.nansore.cedalion.cmd.Minus')).

% Path to string
cpi:procedureCommand(cpi:func(cpi:termAsString(cpi:path(ResourceName, Path), Depth), Str, string), termToString(TTerm, VarNames, Depth, NsList, Str)) :-
	cpi:termAtPath(cpi:path(ResourceName, Path), TTerm, VarNames),
	fileIsLoaded(ResourceName, _, model(_, _, NsList)).

% Edit a certain path with the given string
cpi:procedureCommand(cpi:editFromString(cpi:path(ResourceName, Path), StringRef), doAll([
		stringToTerm(StringRef, NsList, TTerm, VarNames),
		doProc(cpi:edit(cpi:path(ResourceName, Path), TTerm, VarNames))
	])) :-
	fileIsLoaded(ResourceName, _, model(_, _, NsList)).

%%%%% Visualization %%%%%%%

cpi:visualizeDescriptor(cpi:descriptor(Path, Markers), MVis) :-
	cpi:termAtPath(Path, Term::Type, VarNames),
	applyCheckers(cpi:descriptor(Path, Markers), Term::Type, Desc),
	builtin:if(builtin:var(Term::Type),
		visualizeVar(Term::Type, VarNames, Vis),
		% else
		builtin:if(builtin:number(Term::Type),
			visualizeNumber(Term::Type, Vis),
			% else
			builtin:if(builtin:string(Term::Type),
				visualizeString(Term::Type, Vis),
				% else
				visualizeCompound(Desc, Term::Type, Vis)
			)
		)
	),
	applyMarkers(Desc, Vis, MVis).

visualizeVar(_, [builtin:varName(_, Name)], italic(color(label(Name), cpi:rgb(0, 128, 0)))) :- builtin:true.
visualizeNumber(Num::_, label(Num)) :- builtin:true. %TODO: Add real types
visualizeString(Str::_, label(Str)) :- builtin:true. %TODO: Add real types

visualizeCompound(Desc, TTerm, Vis) :-
	builtin:parseTerm(TTerm, Func, TArgs),
	builtin:length(TArgs, typedTerm, Arity),
	subDescriptors(Desc, 0, Arity, SubDescs),
	visualizeNameSubpaths(Func, SubDescs, Vis).

applyCheckers(cpi:descriptor(Path, OldMarkers), TTerm, cpi:descriptor(Path, Markers)) :-
	builtin:findall(Marker, marker, check(Path, TTerm, Marker), NewMarkers),
	append(OldMarkers, NewMarkers, Markers).


subDescriptors(_, Last, Last, []) :- builtin:true.
subDescriptors(cpi:descriptor(cpi:path(Res, Path), Markers), BeforeFirst, Last, [cpi:descriptor(cpi:path(Res, NewPath), MarkersForPath) | SubDescs]) :-
	builtin:succ(BeforeFirst, First),
	append(Path, [First], NewPath),
	markersForPath(Markers, cpi:path(Res, NewPath), MarkersForPath, MarkersLeft),
	subDescriptors(cpi:descriptor(cpi:path(Res, Path), MarkersLeft), First, Last, SubDescs).

markersForPath([], _, [], []) :- builtin:true.
markersForPath([marker(Path, Mark) | Markers], BasePath, MarkersForPath, MarkersLeft) :-
	markersForPath(Markers, BasePath, MarkersForPath1, MarkersLeft1),
	builtin:if(pathIsPrefix(BasePath, Path),
		(
			MarkersForPath = [marker(Path, Mark) | MarkersForPath1],
			MarkersLeft = MarkersLeft1
		),
		( %else
			MarkersForPath = MarkersForPath1,
			MarkersLeft = [marker(Path, Mark) | MarkersLeft1]
		)).			

pathIsPrefix(cpi:path(Res, []), cpi:path(Res, _)) :- builtin:true.
pathIsPrefix(cpi:path(Res, [First | Base]), cpi:path(Res, [First | Path])) :-
	pathIsPrefix(cpi:path(Res, Base), cpi:path(Res, Path)).

visualizeNameSubpaths(Func, SubPaths, Vis) :-
	builtin:if(userVisualization(Func, SubPaths, Vis),
		builtin:true,
		% else
		defaultVisualization(Func, SubPaths, Vis)).

defaultVisualization(Func, SubPaths, Vis) :-
	builtin:if(localName(Func, LFunc),
		builtin:true,
		LFunc::string = Func::string),
	builtin:if(SubPaths::list(cpi:path) = []::list(cpi:path),
		Vis::visualization = label(LFunc)::visualization,
		(% else
			argListForPathList(SubPaths, ArgList),
			Vis::visualization = horiz([label(LFunc), label(!('(')), horiz(ArgList), label(!(')'))])::visualization
		)
	).

argListForPathList([Path], [vis(Path)]) :- builtin:true.
argListForPathList([First | Rest], [vis(First), label(!(',')) | ArgList]) :-
	argListForPathList(Rest, ArgList).

localName(Func, LFunc) :-
	builtin:charCodes(Func, Codes),
	append(PrefCodes, [35 | LocalCodes], Codes), % 35 is the ASCII code for #
	builtin:charCodes(LFunc, LocalCodes).

append([], B, B) :- builtin:true.
append([X | A], B, [X | L]) :-
	append(A, B, L).

signature(visualize(Func, Args, Vis)::statement, [Func::string, Args::list(cpi:path), Vis::visualization]).
visualize(Func, Args, Vis) ~> userVisualization(Func, Args, Vis) :- builtin:true.

visClass(Vis, Class) ~> cpi:termClass(Vis::visualization, Class) :- builtin:true.
visClass(cpi:vis(_), !('net.nansore.cedalion.figures.VisualTerm')).
visClass(vis(_), !('net.nansore.cedalion.figures.VisualTerm')).
visClass(horiz(_), !('net.nansore.cedalion.figures.HorizontalFlow')).
visClass(vert(_), !('net.nansore.cedalion.figures.VerticalFlow')).
visClass(label(_), !('net.nansore.cedalion.figures.LabelFigure')).
visClass(italic(_), !('net.nansore.cedalion.figures.Italic')).
visClass(bold(_), !('net.nansore.cedalion.figures.Bold')).
visClass(color(_, _), !('net.nansore.cedalion.figures.TextColor')).
visClass(lineBorder(_, _, _), !('net.nansore.cedalion.figures.LineBorderFigure')).
visClass(symbol(_), !('net.nansore.cedalion.figures.Symbol')).


visualize(!('[]'), [], label(!('.'))).
visualize(!('.'), [F, R], vert([vis(F), vis(R)])).

% Context menu
contextMenuEntry(TTerm, Path, Name, Proc) ~> cpi:contextMenuEntry(Path, menuItem(Name, Proc)) :- 
	cpi:termAtPath(Path, TTerm, _),
	cpi:procedureCommand(Proc, _).

signature(menuItem(Name, Proc)::menuEntry, [Name::string, Proc::procedure]).
cpi:termClass(menuItem(Name, Proc)::menuEntry, !'net.nansore.cedalion.eclipse.CedalionMenuItem').

% Undo
contextMenuEntry(_, cpi:path(Res, _), !'Undo', cpi:undo(Res)).
contextMenuEntry(_, cpi:path(Res, _), !'Redo', cpi:redo(Res)).

% Markers
applyMarkers(cpi:descriptor(_, []), Vis, Vis) :- builtin:true.
applyMarkers(cpi:descriptor(Path, [marker(MPath, Mark) | Markers]), Vis, MVis) :-
	builtin:if(MPath = Path,
		applyMarker(Mark, Vis, MVis1),
		%else
		MVis1 = Vis),
	applyMarkers(cpi:descriptor(Path, Markers), MVis1, MVis).

applyMarker(Mark, Vis, MVis) :-
	builtin:if(markerVisualization(Mark, Vis, MVis),
		builtin:true,
		MVis = Vis).

markerVis(Mark, Vis, MVis) ~> markerVisualization(Mark, Vis, MVis) :- builtin:true.

markerVis(dummyMarker, Vis, lineBorder(Vis, 1, cpi:rgb(0,0,255))).
markerVis(redMarker, Vis, color(Vis, cpi:rgb(255,0,128))).

% Checkers
check(cpi:path(Res, Path), TTerm, marker(cpi:path(Res, SubPath), dummyMarker)) :-
	\+builtin:var(TTerm),
	builtin:parseTerm(TTerm, _, [_]),
	append(Path, [1], SubPath).

check(Path, TTerm, marker(Path, redMarker)) :-
	builtin:string(TTerm).
